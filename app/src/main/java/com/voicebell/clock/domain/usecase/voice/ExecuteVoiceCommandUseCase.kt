package com.voicebell.clock.domain.usecase.voice

import android.util.Log
import com.voicebell.clock.domain.model.Alarm
import com.voicebell.clock.domain.model.AlarmTone
import com.voicebell.clock.domain.model.DayOfWeek
import com.voicebell.clock.domain.usecase.alarm.CreateAlarmUseCase
import com.voicebell.clock.domain.usecase.timer.StartTimerUseCase
import com.voicebell.clock.util.VoiceCommandParser
import com.voicebell.clock.util.VoiceCommandResult
import java.time.LocalTime
import javax.inject.Inject

/**
 * Use case for executing parsed voice commands.
 *
 * This bridges the gap between voice recognition and actual actions:
 * - Alarm commands -> Create alarm
 * - Timer commands -> Start timer
 * - Query commands -> Return status
 * - Cancel commands -> Cancel alarm/timer
 *
 * Based on the original architecture plan.
 */
class ExecuteVoiceCommandUseCase @Inject constructor(
    private val voiceCommandParser: VoiceCommandParser,
    private val createAlarmUseCase: CreateAlarmUseCase,
    private val startTimerUseCase: StartTimerUseCase
) {

    companion object {
        private const val TAG = "ExecuteVoiceCommand"
    }

    /**
     * Execute a voice command from recognized text.
     *
     * @param recognizedText The text recognized by Vosk
     * @return Result of command execution
     */
    suspend operator fun invoke(recognizedText: String): CommandExecutionResult {
        Log.d(TAG, "Executing voice command: $recognizedText")

        // Parse the command
        val parseResult = voiceCommandParser.parseCommand(recognizedText)

        // Execute based on command type
        return when (parseResult) {
            is VoiceCommandResult.AlarmCommand -> executeAlarmCommand(parseResult)
            is VoiceCommandResult.TimerCommand -> executeTimerCommand(parseResult)
            is VoiceCommandResult.Unknown -> {
                Log.w(TAG, "Unknown command: ${parseResult.originalText}")
                CommandExecutionResult.Error("I didn't understand that command")
            }
            is VoiceCommandResult.Error -> {
                Log.w(TAG, "Parse error: ${parseResult.message}")
                CommandExecutionResult.Error(parseResult.message)
            }
        }
    }

    /**
     * Execute alarm command.
     */
    private suspend fun executeAlarmCommand(command: VoiceCommandResult.AlarmCommand): CommandExecutionResult {
        return try {
            val alarm = createAlarmFromCommand(command)

            Log.d(TAG, "Creating alarm for ${command.time}")
            createAlarmUseCase(alarm)

            val message = buildAlarmConfirmationMessage(command)
            CommandExecutionResult.Success(message)

        } catch (e: Exception) {
            Log.e(TAG, "Error creating alarm", e)
            CommandExecutionResult.Error("Failed to create alarm")
        }
    }

    /**
     * Execute timer command.
     */
    private suspend fun executeTimerCommand(command: VoiceCommandResult.TimerCommand): CommandExecutionResult {
        return try {
            val label = command.label ?: "Voice Timer"

            Log.d(TAG, "Starting timer for ${command.durationMillis}ms")
            startTimerUseCase(
                durationMillis = command.durationMillis,
                label = label
            )

            val message = buildTimerConfirmationMessage(command)
            CommandExecutionResult.Success(message)

        } catch (e: Exception) {
            Log.e(TAG, "Error starting timer", e)
            CommandExecutionResult.Error("Failed to start timer")
        }
    }

    /**
     * Create Alarm domain model from parsed command.
     */
    private fun createAlarmFromCommand(command: VoiceCommandResult.AlarmCommand): Alarm {
        return Alarm(
            id = 0, // Auto-generated by database
            hour = command.time.hour,
            minute = command.time.minute,
            isEnabled = true,
            label = command.label ?: "Voice Alarm",
            alarmTone = AlarmTone.DEFAULT,
            repeatDays = emptySet(), // One-time alarm by default
            vibrate = true,
            flash = false,
            gradualVolumeIncrease = true,
            volumeLevel = 80,
            snoozeEnabled = true,
            snoozeDuration = 10, // 10 minutes default
            snoozeCount = 0,
            maxSnoozeCount = 3,
            preAlarmCount = 0, // No pre-alarms by default
            preAlarmInterval = 7
        )
    }

    /**
     * Build confirmation message for alarm.
     */
    private fun buildAlarmConfirmationMessage(command: VoiceCommandResult.AlarmCommand): String {
        val time = command.time
        val formattedTime = formatTime(time)
        val label = command.label?.let { " '$it'" } ?: ""

        return "Alarm set for $formattedTime$label"
    }

    /**
     * Build confirmation message for timer.
     */
    private fun buildTimerConfirmationMessage(command: VoiceCommandResult.TimerCommand): String {
        val duration = formatDuration(command.durationMillis)
        val label = command.label?.let { " '$it'" } ?: ""

        return "Timer set for $duration$label"
    }

    /**
     * Format time for display (12-hour format with AM/PM).
     */
    private fun formatTime(time: LocalTime): String {
        val hour = time.hour
        val minute = time.minute

        val displayHour = when {
            hour == 0 -> 12
            hour > 12 -> hour - 12
            else -> hour
        }

        val amPm = if (hour < 12) "AM" else "PM"
        val minuteStr = minute.toString().padStart(2, '0')

        return "$displayHour:$minuteStr $amPm"
    }

    /**
     * Format duration for display.
     */
    private fun formatDuration(millis: Long): String {
        val seconds = (millis / 1000).toInt()
        val minutes = seconds / 60
        val hours = minutes / 60

        return when {
            hours > 0 -> {
                val remainingMinutes = minutes % 60
                if (remainingMinutes > 0) {
                    "$hours hour${if (hours > 1) "s" else ""} and $remainingMinutes minute${if (remainingMinutes > 1) "s" else ""}"
                } else {
                    "$hours hour${if (hours > 1) "s" else ""}"
                }
            }
            minutes > 0 -> {
                val remainingSeconds = seconds % 60
                if (remainingSeconds > 0) {
                    "$minutes minute${if (minutes > 1) "s" else ""} and $remainingSeconds second${if (remainingSeconds > 1) "s" else ""}"
                } else {
                    "$minutes minute${if (minutes > 1) "s" else ""}"
                }
            }
            else -> "$seconds second${if (seconds != 1) "s" else ""}"
        }
    }
}

/**
 * Result of executing a voice command.
 */
sealed class CommandExecutionResult {
    /**
     * Command executed successfully.
     */
    data class Success(val message: String) : CommandExecutionResult()

    /**
     * Command execution failed.
     */
    data class Error(val message: String) : CommandExecutionResult()
}
